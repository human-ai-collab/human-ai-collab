<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drawing Test</title>
</head>
<body>
  <script src="p5.js"></script>
  <script>
    // Define Canvas variables
    const IMAGE_SIZE = 512;
    let drawingCanvas;
    let completeCanvas;
    let drawingCTX, completeCTX;
    let pauseTracing = true;

    function debug(thingToDisplay) {
      document.getElementById("debug").innerText = JSON.stringify(thingToDisplay);
    }

    function setup() {
      frameRate(60);
      // Initialize Canvases
      const parentEl = document.querySelector("main");

      // Drawing Canvas
      pixelDensity(1)
      const p5Renderer = createCanvas(IMAGE_SIZE, IMAGE_SIZE);
      drawingCanvas = p5Renderer.canvas;
      drawingCTX = drawingCanvas.getContext('2d', { willReadFrequently: true });
      drawingCTX.willReadFrequently = true;

      // Complete Canvas
      completeCanvas = document.createElement("canvas");
      parentEl.appendChild(completeCanvas);
      completeCanvas.width = IMAGE_SIZE;
      completeCanvas.height = IMAGE_SIZE;
      completeCTX = completeCanvas.getContext('2d', { willReadFrequently: true });
      completeCTX.willReadFrequently = true;
      completeCTX.fillStyle = "#FFF";
      completeCTX.fillRect(0, 0, IMAGE_SIZE, IMAGE_SIZE);

      background("#888");
      let imageObj = document.createElement("img")
      imageObj.onload = function() {
        drawingCTX.drawImage(this, 0, 0);
      };
      imageObj.src = "images/cat-unfinished.png";

      pos = createVector(0,0);
      newPos = createVector(0,0);
      bestNewPos = createVector(0,0);
      resetPos();
    }

    let pos;
    let newPos;
    let bestNewPos;
    let bestNewAngle;
    let startingRot = null;
    let strokeValue = null;
    let smoothStrokeWeight = null;
    let mustResetPos = true; // flag that indicates that the brush pos needs to be reset
    function draw() {
      if (!pauseTracing) {
        if (mustResetPos) {
          findGoodStartingPlace();
          mustResetPos = false;
        } else {
          // Take a few steps each frame.
          const STEPS_PER_FRAME = 4000;
          for (let j = 0; j < STEPS_PER_FRAME; j ++) {
            stepForward();
            if (mustResetPos) break;
          }
        }
      }
    }

    /**
     * Keeps picking random positions on the canvas until we find a good starting place.
     */
    function findGoodStartingPlace() {
      for (let i = 0; i < 10000; i ++) {
        resetPos();
        smoothStrokeWeight = 2;
        if (Math.abs(differenceAt(pos)) > 1) {
          strokeValue = valueAt(pos, completeCTX);
          break;
        }
      }
    }


    /**
     * Steps the AI brush forward, choosing the optimal next step.
     */
    function stepForward() {
      bestNewPos.set(pos);
      let greatestErrorReduction = 0;

      
      // Use this to configure the search area and spread.
      // angleDeviation: how far angle can deviate from previous angle, in radians
      // samples: Number of samples when deciding a turn. Should be at least 3.
      const angleDeviation = startingRot ? 0.5 : Math.PI/2;
      const samples = startingRot ? 15 : 33;
      const leapLength = Math.random() + (startingRot ? 5 : 10);
      if (!startingRot) startingRot = 2 * Math.PI * Math.random();

      // Calculate spread based on the above factors.
      const lowerBound = startingRot - angleDeviation;
      const upperBound = startingRot + angleDeviation;
      const increment = 2 * angleDeviation / (samples - 1);

      let targetWeight = 0;
      for (let newAngle = lowerBound; newAngle <= upperBound; newAngle += increment) {

        // Calculate where this new direction would land us if we took it, with some randomness.
        newPos.set(leapLength, 0);
        newPos.rotate(newAngle);
        newPos.add(pos);

        // Measure how well the stroke color matches this spot.
        const errorWith = Math.abs(valueAt(newPos, completeCTX) - strokeValue);
        const errorWithout = Math.abs(differenceAt(newPos));
        const turnAmount = Math.abs(newAngle - startingRot); // Break ties by prefering the smallest turn.

        const newErrorReduction = errorWithout - errorWith - 0.1 * turnAmount; // Positive values good.

        // const TYPICAL_WEIGHT = 1;
        const TYPICAL_WEIGHT = 1;
        if (newErrorReduction > 0) targetWeight += TYPICAL_WEIGHT * leapLength / samples;
        
        let updateBest = false;
        if (inBounds(newPos)) {
          if (newErrorReduction > greatestErrorReduction) {
            updateBest = true;
          }
        }
        if (updateBest) {
          bestNewPos.set(newPos);
          bestNewAngle = newAngle;
          greatestErrorReduction = newErrorReduction;
        }
      }

      if (greatestErrorReduction > 0) {
        smoothStrokeWeight += (targetWeight - smoothStrokeWeight) / 10;
        strokeWeight(smoothStrokeWeight);
        const strokeOpacity = 200 // out of 255. The greater, the more opaque
        stroke(strokeValue, strokeValue, strokeValue, strokeOpacity);
        line(pos.x, pos.y, bestNewPos.x, bestNewPos.y);
        pos.lerp(bestNewPos, 0.2);
      } else {
        if (Math.random() < 0.1) {
          mustResetPos = true;
        } else {
          startingRot = null;
        }
      }
    }

    /**
     * Resets the AI brush to a random position on the screen, pointing it in a random direction.
     */
    function resetPos() {
      pos.x = Math.floor(Math.random() * IMAGE_SIZE);
      pos.y = Math.floor(Math.random() * IMAGE_SIZE);
      startingRot = null;
    }

    /**
     * Calculate the the value of a canvas context at a certain position.
     * @param {P5 Vector} pos - The position to search at
     * @param {Canvas Context} ctx - The context of the canvas to search.
     * @return {number} The difference
     */
    function valueAt(pos, ctx) {
      return ctx.getImageData(Math.floor(pos.x), Math.floor(pos.y), 1, 1).data[0]
    }

    /**
     * Calculate the difference between what is and what should be. Positive if it should be lighter, negative if it should be darker.
     * @param {P5 Vector} pos - The position to search at
     * @return {number} The difference
     */
    function differenceAt(pos) {
      return valueAt(pos, completeCTX) - valueAt(pos, drawingCTX);
    }

    function inBounds(pos) {
      return pos.x >= 0 && pos.y >= 0 && pos.x < IMAGE_SIZE && pos.y < IMAGE_SIZE;
    }

    function complete() {
      sendImage()
      .then(resp => resp.json())
      .then(data => loadDataURL(data.image, completeCanvas))
      .then(_ => {pauseTracing = false})
    }

    function loadDataURL(dataURL, canvas) {
      const myPromise = new Promise((resolve, reject) => {
        let context = canvas.getContext('2d');
        // load image from data url
        let imageObj = document.createElement("img")
        imageObj.onload = function() {
          context.drawImage(this, 0, 0);
          setTimeout(_ => resolve(), 1000)
          // resolve();
        };
        imageObj.src = dataURL;
      });
    }
    function sendImage() {
      return fetch("/api/complete", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          "image": canvasToBase64(drawingCanvas)
        })
      });
    }
    function canvasToBase64(canvas) {
      let imageData = canvas.toDataURL('image/png'); // produces a base64 image string
      return imageData;
    }
  </script>
  <button onclick="complete()">Complete</button>
  <div>Debug: <span id="debug"></span></div>
</body>
</html>